<!doctype html>
<html>
<head>
<meta charset="utf-8">
<style>
  body { margin: 0; overflow: hidden; background: #111; }
  svg { display: block; }
  .land { fill: #3c527e; stroke: #bbb; stroke-width: 1px; }
  .border { fill: none; stroke: #aaa; stroke-width: 1px; }
  .graticule { fill: none; stroke: #fff; stroke-width: 0.5px; stroke-dasharray: 3 3; }
  .latlon-label, .capital-label { fill: #fff; font-size: 12px; font-family: sans-serif; pointer-events: none; }
  .capital { fill: #ff4500; stroke: none; pointer-events: none; }
  .minimap { position: absolute; bottom: 10px; right: 10px; border: 1px solid #555; background: #111; }
  .minimap-water { fill: #111; }
  .minimap-rect { fill: none; stroke: red; stroke-width: 2px; }
</style>
</head>
<body>
<svg id="mainMap" width="100vw" height="100vh"></svg>
<svg id="miniMap" width="400" height="200" class="minimap"></svg>

<script src="https://d3js.org/d3.v7.min.js"></script>
<script src="https://unpkg.com/d3-geo-projection@4"></script>
<script src="https://unpkg.com/topojson-client@3"></script>

<script>
const width = window.innerWidth;
const height = window.innerHeight;
const padding = 20;
const zoomx = 6;
const labelOffset = 10;

// ----------------- PROJECTION -----------------
const projection = d3.geoWinkel3()
  .scale((width / (2 * Math.PI)) * zoomx)
  .translate([width / 2, height / 2]);
const path = d3.geoPath().projection(projection);
const graticule = d3.geoGraticule10();

// ----------------- MAIN MAP -----------------
const mainSvg = d3.select("#mainMap");
const mainG = mainSvg.append("g");

// ocean background
mainG.append("rect")
  .attr("x", 0).attr("y", 0)
  .attr("width", width)
  .attr("height", height)
  .attr("fill", "#3c527e");

// load countries
d3.json("https://cdn.jsdelivr.net/npm/world-atlas@2/countries-10m.json").then(world => {
  const countries = topojson.feature(world, world.objects.countries);

  mainG.selectAll("path.land")
    .data(countries.features)
    .join("path")
    .attr("class", "land")
    .attr("d", path);

  mainG.selectAll("path.border")
    .data(countries.features)
    .join("path")
    .attr("class", "border")
    .attr("d", path)
    .attr("stroke-width", 1);

  mainG.append("path")
    .datum(graticule)
    .attr("class", "graticule")
    .attr("d", path);
});

// ----------------- LABELS -----------------
const labelG = mainSvg.append("g").attr("class", "latlon-label");
const capitalsG = mainSvg.append("g").attr("class", "capitals");

function updateLabels(transform) {
  labelG.selectAll("*").remove();
  const step = 30;
  const proj = ([lon, lat]) => {
    const p = projection([lon, lat]);
    if (!p) return null;
    return [p[0] * transform.k + transform.x, p[1] * transform.k + transform.y];
  };
  for (let lat=-90; lat<=90; lat+=step){
    const pts = d3.range(-180,181,1).map(lon=>proj([lon,lat])).filter(p=>p);
    if(!pts.length) continue;
    const left = pts.find(p=>p[0]>=padding);
    if(left) labelG.append("text").attr("x",padding).attr("y",left[1])
      .text(`${Math.abs(lat)}째${lat>0?'N':'S'}`).attr("class","latlon-label");
    const right = pts.slice().reverse().find(p=>p[0]<=width-padding);
    if(right) labelG.append("text").attr("x",width-padding-30).attr("y",right[1])
      .text(`${Math.abs(lat)}째${lat>0?'N':'S'}`).attr("class","latlon-label");
  }
  for (let lon=-180; lon<=180; lon+=step){
    const pts = d3.range(-90,91,1).map(lat=>proj([lon,lat])).filter(p=>p);
    if(!pts.length) continue;
    const top = pts.find(p=>p[1]>=padding);
    if(top) labelG.append("text").attr("x",top[0]).attr("y",padding)
      .text(`${Math.abs(lon)}째${lon>0?'E':'W'}`).attr("class","latlon-label");
    const bottom = pts.slice().reverse().find(p=>p[1]<=height-padding);
    if(bottom) labelG.append("text").attr("x",bottom[0]).attr("y",height-padding)
      .text(`${Math.abs(lon)}째${lon>0?'E':'W'}`).attr("class","latlon-label");
  }
}

// ----------------- ZOOM & PAN -----------------
const zoom = d3.zoom()
  .scaleExtent([1, 1])
  .on("zoom", (event)=>{
    mainG.attr("transform",event.transform);
    capitalsG.attr("transform",event.transform);
    updateLabels(event.transform);
    updateMinimapRect(event.transform);
  });
mainSvg.call(zoom);

// ----------------- MINIMAP -----------------
const miniSvg = d3.select("#miniMap");
const miniG = miniSvg.append("g");
const miniWidth = +miniSvg.attr("width");
const miniHeight = +miniSvg.attr("height");
const miniProjection = d3.geoWinkel3()
  .scale(60)
  .translate([miniWidth/2, miniHeight/2]);
const miniPath = d3.geoPath().projection(miniProjection);
miniG.append("rect")
  .attr("class","minimap-water")
  .attr("x",0).attr("y",0)
  .attr("width",miniWidth)
  .attr("height",miniHeight);
const softColours = ["#a8dadc","#f1faee","#ffe5d9","#ffd6a5","#cdb4db","#b5ead7","#ffb3c6","#f7ede2"];
d3.json("https://cdn.jsdelivr.net/npm/world-atlas@2/countries-110m.json").then(world110=>{
  const countries110 = topojson.feature(world110,world110.objects.countries);
  miniG.selectAll("path.land")
    .data(countries110.features)
    .join("path")
    .attr("d",miniPath)
    .attr("fill",()=>softColours[Math.floor(Math.random()*softColours.length)])
    .attr("stroke","#666")
    .attr("stroke-width",0.3);
  miniG.append("rect")
    .attr("class","minimap-rect")
    .attr("x",0).attr("y",0)
    .attr("width",0)
    .attr("height",0);
});

// ----------------- MINIMAP RECT -----------------
function updateMinimapRect(transform){
  const topLeft = projection.invert([0-transform.x,0-transform.y].map(d=>d/transform.k));
  const bottomRight = projection.invert([width-transform.x,height-transform.y].map(d=>d/transform.k));
  if(!topLeft||!bottomRight) return;
  const coords=[topLeft,bottomRight].map(miniProjection);
  miniG.select(".minimap-rect")
    .attr("x",Math.min(coords[0][0],coords[1][0]))
    .attr("y",Math.min(coords[0][1],coords[1][1]))
    .attr("width",Math.abs(coords[1][0]-coords[0][0]))
    .attr("height",Math.abs(coords[1][1]-coords[0][1]));
}

// ----------------- LOAD CAPITALS -----------------
async function loadCapitals(){
  const query = `[out:json][timeout:25];node["place"="city"]["capital"="yes"];out body;`;
  const url = "https://overpass-api.de/api/interpreter?data="+encodeURIComponent(query);
  try{
    const resp = await fetch(url);
    const json = await resp.json();
    const capitals = json.elements.filter(d=>d.tags && d.tags.name);

    // Draw circles
    capitalsG.selectAll(".capital")
      .data(capitals)
      .join("circle")
      .attr("class","capital")
      .attr("cx",d=>projection([d.lon,d.lat])[0])
      .attr("cy",d=>projection([d.lon,d.lat])[1])
      .attr("r",3);

    // Draw labels above the dot
    capitalsG.selectAll("text")
      .data(capitals)
      .join("text")
      .attr("x",d=>projection([d.lon,d.lat])[0])
      .attr("y",d=>projection([d.lon,d.lat])[1]-labelOffset)
      .text(d=>d.tags.name)
      .attr("class","capital-label")
      .attr("text-anchor","middle");

  }catch(e){console.error("Failed to load capitals",e);}
}

loadCapitals();
updateLabels({k:1,x:0,y:0});
</script>
</body>
</html>
