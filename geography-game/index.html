<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Geography A to Z</title>
<link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Rounded" rel="stylesheet">
<link rel="icon" type="image/png" href="https://coe-chat.vercel.app/geography-game/favicon.png">
<style>
body { font-family:sans-serif; margin:0; padding:0; text-align:center; background:#121212; color:#eee; }
h1 { margin:1em 0 0.3em; }
#map { width:100%; height:70vh; border:1px solid #444; background:#1e1e1e; border-radius:12px; }
#controls { margin:1em; display:flex; align-items:center; justify-content:center; gap:8px; position:relative; }
input[type=text] { padding:0.5em; width:250px; border-radius:8px; border:1px solid #555; background:#222; color:#eee; flex-shrink:0; }
button { width:40px; height:40px; border-radius:50%; border:none; background:#007acc; color:#fff; cursor:pointer; font-family:'Material Symbols Rounded'; font-variation-settings:'FILL' 1,'wght' 400,'GRAD' 0,'opsz' 48; font-size:20px; display:flex; align-items:center; justify-content:center; padding:0; }
button:hover { background:#005f99; }
#autocomplete-list { position:absolute; top:4em; left:0; width:250px; border:1px solid #555; border-radius:8px; background:#222; max-height:150px; overflow-y:auto; z-index:1000; box-shadow:0 2px 6px rgba(0,0,0,0.5); }
.autocomplete-item { padding:0.3em 0.5em; cursor:pointer; }
.autocomplete-item:hover { background:#444; }
.country { fill:none; stroke:#555; stroke-width:0.25px; } /* thinner outline */
.revealed { stroke:#fff; stroke-width:0.25px; }
#timer { margin-left:12px; font-weight:bold; }
#pause-btn { background:#ff9800; }
#pause-btn:hover { background:#cc7a00; }
#pause-overlay, #results-screen, #start-screen {
  position:fixed; top:0; left:0; width:100%; height:100%;
  background:rgba(0,0,0,0.9); display:flex; flex-direction:column;
  justify-content:center; align-items:center; z-index:2000; color:#fff;
  text-align:center; display:none;
}
#pause-overlay button, #results-screen button, #start-screen button {
  margin-top:1em; padding:0.5em 1em; font-size:1em;
  border:none; border-radius:8px; cursor:pointer;
  background:#007acc; color:#fff; width:auto; height:auto;
  font-family:sans-serif;
}
#start-screen img { width:100px; height:100px; margin-bottom:1em; }
#start-screen h1 { margin-bottom:0.5em; }
#popup-country {
  position:fixed;
  pointer-events:none;
  background:rgba(30,30,30,0.95);
  color:#fff;
  padding:0.4em 0.8em;
  border-radius:8px;
  font-size:1em;
  z-index:3000;
  box-shadow:0 2px 8px rgba(0,0,0,0.5);
  display:none;
  transition:opacity 0.15s;
}
</style>
<script src="https://d3js.org/d3.v7.min.js"></script>
<script src="https://unpkg.com/topojson-client@3"></script>
</head>
<body>
<h1>Geography A to Z</h1>
<div id="controls">
  <div id="prompt">Loading game...</div>
  <input id="answer" type="text" placeholder="Type country name" autocomplete="off">
  <div id="autocomplete-list"></div>
  <button id="submit-btn"><span class="material-symbols-rounded" style="font-variation-settings:'FILL' 1;font-size:24px;">arrow_forward_ios</span></button>
  <button id="pause-btn" title="Pause">&#10073;&#10073;</button>
  <div id="timer">0:00</div>
</div>
<svg id="map"></svg>
<div id="popup-country"></div>

<div id="start-screen">
  <img src="https://coe-chat.vercel.app/geography-game/favicon.png" alt="Game Logo">
  <h1>Geography A to Z</h1>
  <p>Select a mode to start:</p>
  <button onclick="startGame('Easy')">Easy</button>
  <button onclick="startGame('Medium')">Medium</button>
  <button onclick="startGame('Normal')">Normal</button>
  <button onclick="startGame('Hard')">Hard</button>
</div>

<div id="pause-overlay">
  <div>Game Paused</div>
  <button id="resume-btn">Resume</button>
</div>

<div id="results-screen">
  <div id="results-text"></div>
  <button onclick="location.reload()">Play Again</button>
  <button id="close-results-btn">Close</button>
</div>

<script>
let countriesData=[], features=[], projection, path, svg, mapGroup;
let round=1, currentContinent="", currentLetter="";
let revealedCountries=new Set(), nameIndex=new Map();
let featureByCCA3=new Map(), featureByName=new Map();
let wrongGuesses=0, gameMode="Normal";
let startTime=null, elapsed=0, timerInterval=null, paused=false;
const continentOrder=["Europe","Oceania","Americas","Asia","Africa","Antarctic"];
let continentIndex=0;

// Improved manual mapping for problematic countries
const manualFeatureMap={
  northmacedonia:"MKD", southsudan:"SSD", democraticrepublicofthecongo:"COD",
  centralafricanrepublic:"CAF", republicofthecongo:"COG", unitedstates:"USA",
  stvincentandthegrenadines:"VCT", bosniaandherzegovina:"BIH", puertorico:"PRI",
  papuanewguinea:"PNG", libya:"LBY", dominicanrepublic:"DOM",
  "sãotoméandpríncipe":"STP", "sao tome and principe":"STP", "sao tome":"STP",
  "são tomé":"STP", "são tomé e príncipe":"STP", "sao tome e principe":"STP",
  svalbard:"SJM", "ivorycoast":"CIV", "cotedivoire":"CIV", "capeverde":"CPV",
  "timorleste":"TLS", "easttimor":"TLS", "vaticancity":"VAT", "holysee":"VAT",
  "eswatini":"SWZ", "swaziland":"SWZ", "burma":"MMR", "myanmar":"MMR",
  "palestine":"PSE", "palestinianterritory":"PSE", "palestinian territories":"PSE"
};

function normalizeName(s){ return s.toLowerCase().replace(/[^a-z]+/g,''); }

async function init(){
  svg=d3.select("#map");
  projection=d3.geoMercator().scale(120).translate([window.innerWidth/2, window.innerHeight/2.2]);
  path=d3.geoPath().projection(projection);
  mapGroup=svg.append("g").attr("class","map-content");
  svg.call(d3.zoom().scaleExtent([1,16]).on("zoom",event=>{mapGroup.attr("transform",event.transform);})); // increased zoom

  const rc=await fetch('https://restcountries.com/v3.1/all?fields=cca2,cca3,name,region,altSpellings').then(r=>r.json());
  rc.forEach(c=>{
    const cca3=c.cca3||"", cca2=c.cca2||"", common=c.name.common, region=c.region||"Other";
    const aliases=new Set([common,c.name.official,...(c.altSpellings||[])]);
    // Add normalized aliases for edge cases
    if(common==="São Tomé and Príncipe") aliases.add("Sao Tome and Principe");
    if(common==="Democratic Republic of the Congo") aliases.add("DR Congo");
    if(common==="Central African Republic") aliases.add("CAR");
    if(common==="Dominican Republic") aliases.add("Dom. Rep.");
    if(common==="Republic of the Congo") aliases.add("Congo");
    if(common==="Ivory Coast") aliases.add("Côte d'Ivoire");
    if(common==="East Timor") aliases.add("Timor-Leste");
    if(common==="Vatican City") aliases.add("Holy See");
    if(common==="Myanmar") aliases.add("Burma");
    if(common==="Eswatini") aliases.add("Swaziland");
    if(common==="Palestine") aliases.add("Palestinian Territories");
    const rec={name:common,cca2,cca3,region,aliases:[...aliases]};
    countriesData.push(rec);
    rec.aliases.forEach(a=>nameIndex.set(normalizeName(a),rec));
  });

  const topo=await fetch('https://unpkg.com/world-atlas@2/countries-50m.json').then(r=>r.json());
  const objKey=Object.keys(topo.objects)[0];
  features=topojson.feature(topo, topo.objects[objKey]).features;
  features.forEach(f=>{
    const props=f.properties||{};
    const iso=props.iso_a3||props.ISO_A3||props.ADM0_A3||"";
    const pname=props.name||props.NAME||props.ADMIN||"";
    if(iso) featureByCCA3.set(iso,f);
    if(pname) featureByName.set(normalizeName(pname),f);
  });

  mapGroup.selectAll("path").data(features).join("path").attr("d",path).attr("class","country");
  document.getElementById("start-screen").style.display="flex";
}

function startGame(mode){
  gameMode=mode; document.getElementById("start-screen").style.display="none";
  startTimer(); nextRound();
}

function getLargestPolygon(feature) {
  // For MultiPolygon, return the largest polygon by area
  if (feature.geometry.type === "MultiPolygon") {
    let maxArea = 0, largest = null;
    feature.geometry.coordinates.forEach(coords => {
      const poly = {type: "Polygon", coordinates: coords};
      const area = d3.geoArea({type: "Feature", geometry: poly});
      if (area > maxArea) { maxArea = area; largest = poly; }
    });
    if (largest) return {type: "Feature", geometry: largest, properties: feature.properties};
  }
  return feature;
}

function getAllPolygons(feature) {
  // Returns an array of features, one for each polygon
  if (feature.geometry.type === "MultiPolygon") {
    return feature.geometry.coordinates.map(coords => ({
      type: "Feature",
      geometry: {type: "Polygon", coordinates: coords},
      properties: feature.properties
    }));
  }
  return [feature];
}

// Improved feature lookup for problematic countries
function getFeature(rec){
  const key=normalizeName(rec.name);
  // 1) manual mapping
  if(manualFeatureMap[key] && featureByCCA3.has(manualFeatureMap[key])) return featureByCCA3.get(manualFeatureMap[key]);
  // 2) direct ISO lookup
  if(featureByCCA3.has(rec.cca3)) return featureByCCA3.get(rec.cca3);
  // 3) TopoJSON name lookup
  if(featureByName.has(key)) return featureByName.get(key);
  // 4) fallback: aliases
  for(let alias of rec.aliases){
    const aliasKey=normalizeName(alias);
    if(manualFeatureMap[aliasKey] && featureByCCA3.has(manualFeatureMap[aliasKey])) return featureByCCA3.get(manualFeatureMap[aliasKey]);
    const f=featureByName.get(aliasKey);
    if(f) return f;
  }
  // 5) fallback: partial match (for edge cases)
  for(let [name, f] of featureByName){
    if(name.includes(key) || key.includes(name)) return f;
  }
  // 6) South Sudan and DR Congo hard fallback
  if(rec.name === "South Sudan") return featureByCCA3.get("SSD");
  if(rec.name === "Democratic Republic of the Congo") return featureByCCA3.get("COD");
  return null;
}

function computeVisualCenter(feature){
  // Use d3.geoCentroid for better accuracy
  try {
    const centroid = d3.geoCentroid(feature);
    return projection(centroid);
  } catch {
    return path.centroid(feature);
  }
}

function revealCountry(rec){
  if(revealedCountries.has(rec.name)) return;
  revealedCountries.add(rec.name);
  let feature=getFeature(rec); if(!feature) return;

  // For USA, DRC, SS: fill all polygons with stretched flag
  if(rec.cca3==="USA" || rec.cca3==="SSD" || rec.cca3==="COD") {
    const polygons = getAllPolygons(feature);
    polygons.forEach((poly, i) => {
      const clipId = `clip-${rec.cca3}-${i}`;
      mapGroup.append("clipPath").attr("id",clipId).append("path").attr("d",path(poly));
      const bbox=path.bounds(poly);
      const boxWidth=bbox[1][0]-bbox[0][0], boxHeight=bbox[1][1]-bbox[0][1];
      const flagUrl = rec.cca2 ? `https://flagcdn.com/w320/${rec.cca2.toLowerCase()}.png` : "";
      mapGroup.append("image")
        .attr("href", flagUrl)
        .attr("x", bbox[0][0]).attr("y", bbox[0][1])
        .attr("width", boxWidth).attr("height", boxHeight)
        .attr("preserveAspectRatio","none")
        .attr("clip-path", `url(#${clipId})`)
        .attr("style","pointer-events:none;")
        .on("error", function() {
          d3.select(this).remove();
          mapGroup.append("path")
            .attr("d", path(poly))
            .attr("clip-path", `url(#${clipId})`)
            .attr("fill", "#005f99")
            .attr("opacity", 0.7)
            .attr("stroke", "#fff").attr("stroke-width", 0.8);
        });
    });
    // Highlight all polygons for these countries by matching all features with the same ISO code
    const iso = rec.cca3;
    mapGroup.selectAll("path.country")
      .filter(d => {
        const props = d.properties || {};
        // Some TopoJSON features may have ISO_A3 or ADM0_A3
        return (props.iso_a3 === iso || props.ISO_A3 === iso || props.ADM0_A3 === iso);
      })
      .classed("revealed",true)
      .raise();
    return;
  }
  // France: shift image left and use fixed aspect ratio to show all three colors
  else if(rec.cca2==="FR") {
    const clipId=`clip-${rec.cca3 || normalizeName(rec.name)}`;
    mapGroup.append("clipPath").attr("id",clipId).append("path").attr("d",path(feature));
    const bbox=path.bounds(feature);
    const boxWidth=bbox[1][0]-bbox[0][0], boxHeight=bbox[1][1]-bbox[0][1];
    // Use flag aspect ratio (3:2), shift left by 1/3 of width to show blue/red
    const flagWidth = boxHeight * 1.5;
    const xOffset = bbox[0][0] - (flagWidth - boxWidth) / 2;
    mapGroup.append("image")
      .attr("href", "https://flagcdn.com/w320/fr.png")
      .attr("x", xOffset).attr("y", bbox[0][1])
      .attr("width", flagWidth).attr("height", boxHeight)
      .attr("preserveAspectRatio","xMinYMin slice")
      .attr("clip-path", `url(#${clipId})`)
      .attr("style","pointer-events:none;")
      .on("error", function() {
        d3.select(this).remove();
        mapGroup.append("path")
          .attr("d", path(feature))
          .attr("clip-path", `url(#${clipId})`)
          .attr("fill", "#005f99")
          .attr("opacity", 0.7)
          .attr("stroke", "#fff").attr("stroke-width", 0.8);
      });
    // Highlight France by matching all features with the same ISO code
    const iso = rec.cca3;
    mapGroup.selectAll("path.country")
      .filter(d => {
        const props = d.properties || {};
        return (props.iso_a3 === iso || props.ISO_A3 === iso || props.ADM0_A3 === iso);
      })
      .classed("revealed",true)
      .raise();
    return;
  }
  // All other countries: stretch flag as before
  else {
    const clipId=`clip-${rec.cca3 || normalizeName(rec.name)}`;
    mapGroup.append("clipPath").attr("id",clipId).append("path").attr("d",path(feature));
    const bbox=path.bounds(feature);
    const boxWidth=bbox[1][0]-bbox[0][0], boxHeight=bbox[1][1]-bbox[0][1];
    const flagUrl = rec.cca2 ? `https://flagcdn.com/w320/${rec.cca2.toLowerCase()}.png` : "";
    const img = mapGroup.append("image")
      .attr("href", flagUrl)
      .attr("x", bbox[0][0]).attr("y", bbox[0][1])
      .attr("width", boxWidth).attr("height", boxHeight)
      .attr("preserveAspectRatio","none")
      .attr("clip-path", `url(#${clipId})`)
      .attr("style","pointer-events:none;")
    img.on("error", function() {
      d3.select(this).remove();
      mapGroup.append("path")
        .attr("d", path(feature))
        .attr("clip-path", `url(#${clipId})`)
        .attr("fill", "#005f99")
        .attr("opacity", 0.7)
        .attr("stroke", "#fff").attr("stroke-width", 0.8);
    });

    // Highlight country by matching all features with the same ISO code
    const iso = rec.cca3;
    mapGroup.selectAll("path.country")
      .filter(d => {
        const props = d.properties || {};
        return (props.iso_a3 === iso || props.ISO_A3 === iso || props.ADM0_A3 === iso);
      })
      .classed("revealed",true)
      .raise();
  }

  // At the end of each reveal, add mouse events for popup on revealed country
  setTimeout(() => {
    const iso = rec.cca3;
    mapGroup.selectAll("path.country")
      .filter(d => {
        const props = d.properties || {};
        return (props.iso_a3 === iso || props.ISO_A3 === iso || props.ADM0_A3 === iso);
      })
      .on("mousemove", function(event, d) {
        const popup = document.getElementById("popup-country");
        popup.textContent = rec.name;
        popup.style.display = "block";
        popup.style.left = (event.clientX + 12) + "px";
        popup.style.top = (event.clientY - 10) + "px";
        popup.style.opacity = "1";
      })
      .on("mouseleave", function() {
        const popup = document.getElementById("popup-country");
        popup.style.opacity = "0";
        popup.style.display = "none";
      });
  }, 10);
}

// nextRound, submitAnswer, autocomplete, timer, pause/resume, endGame

function nextRound(){
  const submitSpan=document.querySelector("#submit-btn span");
  submitSpan.textContent="arrow_forward_ios"; submitSpan.style.fontSize="24px";
  let remaining;
  if(gameMode==="Normal"||gameMode==="Hard"){
    while(continentIndex<continentOrder.length){
      const cont=continentOrder[continentIndex];
      remaining=countriesData.filter(c=>!revealedCountries.has(c.name)&&c.region===cont);
      if(remaining.length>0) break;
      continentIndex++;
    }
    if(continentIndex>=continentOrder.length){ endGame(); return; }
  }else{
    remaining=countriesData.filter(c=>!revealedCountries.has(c.name)&&c.region!=="Antarctic");
  }
  if(!remaining || !remaining.length){ endGame(); return; }
  const rec=remaining[Math.floor(Math.random()*remaining.length)];
  currentContinent=rec.region; currentLetter=rec.name[0].toUpperCase();
  let promptText=`Round ${round}: Name a country starting with "${currentLetter}"`;
  if(gameMode==="Normal"||gameMode==="Hard") promptText=`Round ${round}: Name a country in ${currentContinent} starting with "${currentLetter}"`;
  document.getElementById("prompt").innerText=promptText;
}

const answerInput=document.getElementById("answer"), autocompleteList=document.getElementById("autocomplete-list");
answerInput.addEventListener("input", function(){
  if(gameMode==="Hard"||gameMode==="Medium"){ autocompleteList.innerHTML=""; return; }
  const val=normalizeName(this.value); autocompleteList.innerHTML="";
  if(!val) return;
  let matches=countriesData.map(c=>c.name).filter(n=>normalizeName(n).startsWith(val)&&!revealedCountries.has(n));
  matches.slice(0,10).forEach(name=>{
    const div=document.createElement("div");
    div.classList.add("autocomplete-item"); div.textContent=name;
    div.onclick=()=>{ answerInput.value=name; autocompleteList.innerHTML=""; submitAnswer(); };
    autocompleteList.appendChild(div);
  });
});
document.addEventListener("click", e=>{ if(e.target!==answerInput) autocompleteList.innerHTML=""; });
answerInput.addEventListener("keydown", e=>{ if(e.key==="Enter"){ submitAnswer(); autocompleteList.innerHTML=""; } });

document.getElementById("submit-btn").addEventListener("click", submitAnswer);

function submitAnswer(){
  if(paused) return;
  const input=answerInput.value.trim(); answerInput.value=""; autocompleteList.innerHTML="";
  if(!input) return;
  if(input==="|re"){ countriesData.forEach(revealCountry); endGame(); return; }
  const rec=nameIndex.get(normalizeName(input));
  const submitSpan=document.querySelector("#submit-btn span");
  if(!rec){ alert(`❌ Invalid input: ${input}`); wrongGuesses++; return; }
  if((gameMode==="Normal"||gameMode==="Hard") && rec.region!==currentContinent){ alert(`❌ Wrong continent: ${rec.name} is in ${rec.region}`); wrongGuesses++; return; }
  if(!rec.name.toUpperCase().startsWith(currentLetter)){ alert(`❌ Wrong letter: ${rec.name} does not start with ${currentLetter}`); wrongGuesses++; return; }
  submitSpan.textContent="check_circle"; submitSpan.style.fontSize="36px";
  revealCountry(rec); round++; setTimeout(nextRound,500);
}

function startTimer(){ startTime=Date.now()-elapsed; timerInterval=setInterval(updateTimer,1000); }
function updateTimer(){ elapsed=Date.now()-startTime; const totalSec=Math.floor(elapsed/1000); const min=Math.floor(totalSec/60), sec=totalSec%60; document.getElementById("timer").textContent=`${min}:${sec.toString().padStart(2,"0")}`; }
function pauseTimer(){ clearInterval(timerInterval); paused=true; document.getElementById("pause-overlay").style.display="flex"; }
function resumeTimer(){ startTimer(); paused=false; document.getElementById("pause-overlay").style.display="none"; }
function endGame(){ clearInterval(timerInterval); const totalSec=Math.floor(elapsed/1000); const min=Math.floor(totalSec/60), sec=totalSec%60; const correct=round-1; const total=correct+wrongGuesses; const percent= total>0 ? ((correct/total)*100).toFixed(1) : 100;
document.getElementById("results-text").innerHTML=`<div>Game Over! (${gameMode} Mode)</div><div>Time: ${min}:${sec.toString().padStart(2,"0")}</div><div>Wrong Attempts: ${wrongGuesses}</div><div>Accuracy: ${percent}%</div>`;
document.getElementById("results-screen").style.display="flex"; }

document.getElementById("pause-btn").addEventListener("click", ()=>{ if(!paused) pauseTimer(); });
document.getElementById("resume-btn").addEventListener("click", resumeTimer);
document.getElementById("close-results-btn").addEventListener("click", ()=>{ document.getElementById("results-screen").style.display="none"; });

init();
</script>
</body>
</html>
